{
  "markdown_sections": [
    "## Build a smart loan recovery system that involves creating a machine learning model that can predict the likelihood of loan repayment and identify high-risk borrowers. Here's a step-by-step guide to help you build such a model:\n### Problem Definition\n\u2022\tDefine the objective: Predict the probability of loan repayment and identify high-risk borrowers.\n\u2022\tIdentify the target variable: Loan repayment status (e.g., paid, defaulted, or overdue).\nData Collection\n\u2022\tCollect relevant data: Loan applications, credit history, payment records, and borrower information.\n\u2022\tPreprocess the data: Handle missing values, normalize/scale features, and transform variables \u00b9 \u00b2 \u00b3.\nFeature Engineering\n\u2022\tExtract relevant features: Credit score, loan amount, interest rate, payment history, and borrower demographics.\n\u2022\tUse techniques like correlation analysis and recursive feature elimination to select the most informative features \u2074 \u00b2.\nModel Selection\n\u2022\tChoose a suitable algorithm: Logistic Regression, Decision Trees, Random Forest, or Support Vector Machines.\n\u2022\tConsider using ensemble methods like bagging or boosting to improve model performance.\nModel Training and Evaluation\n\u2022\tTrain the model: Use a training dataset to fit the model and tune hyperparameters.\n\u2022\tEvaluate the model: Use metrics like accuracy, precision, recall, F1-score, and AUC-ROC to assess model performance \u2075 \u00b9.\nModel Deployment\n\u2022\tDeploy the model: Integrate the model into a loan recovery system to predict the likelihood of loan repayment for new borrowers.\n\u2022\tMonitor and update: Continuously monitor the model's performance and update it as necessary to ensure optimal results.\nSome popular machine learning algorithms for building a smart loan recovery system include \u2075 \u00b2:\n\u2022\tLogistic Regression: A popular choice for binary classification problems like loan repayment prediction.\n\u2022\tDecision Trees: Can handle complex interactions between variables and provide interpretable results.\n\u2022\tRandom Forest: An ensemble method that combines multiple decision trees to improve model performance.\n\u2022\tSupport Vector Machines: Can handle high-dimensional data and provide robust predictions.\n",
    "# MODEL DEPLOYMENT"
  ],
  "code_sections": [
    "#import all the libraries\nimport pandas as pd\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.svm import SVC\nfrom sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score, roc_auc_score",
    "",
    "#read the csv file\ndata_path = 'Smart Loan Recovery System.csv' \ndf = pd.read_csv(data_path)\ndf.head()",
    "# Convert repayment status into numbers (adjust names to your dataset)\ndf['target'] = df['Recovery_Status'].map({\n    'Fully Recovered': 1,\n    'Partially Recovered': 1,\n    'Written Off': 0\n})",
    "# Drop rows where target is missing\ndf = df.dropna(subset=['target'])",
    "# Fill missing values\ndf = df.fillna(df.median(numeric_only=True))",
    "# Select numeric columns only\nX = df.select_dtypes(include=['int64', 'float64'])\nX = X.drop(columns=['target'], errors='ignore')\n\ny = df['target']",
    "# Scale features\nscaler = StandardScaler()\nX_scaled = scaler.fit_transform(X)",
    "#let's create a few engineering features\ndf['debt_to_income'] = df['Loan_Amount'] / (df['Monthly_Income'] + 1)\n\ndf['loan_to_collateral'] = df['Outstanding_Loan_Amount'] / (df['Collateral_Value'] + 1)\n\ndf['high_interest'] = (df['Interest_Rate'] > df['Interest_Rate'].median()).astype(int)\n\ndf[['debt_to_income', 'loan_to_collateral', 'high_interest']].head()",
    "#split train and test the model\nX = df[['debt_to_income', 'loan_to_collateral', 'high_interest']]\ny = df['target']\n\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)",
    "#let's choose our models\nmodels = {\n    \"Logistic Regression\": LogisticRegression(),\n    \"Decision Tree\": DecisionTreeClassifier(),\n    \"Random Forest\": RandomForestClassifier(),\n    \"SVM\": SVC(probability=True)\n}",
    "#lets check if the model is train successfully\ntrained = {}\n\nfor name, model in models.items():\n    model.fit(X_train, y_train)\n    trained[name] = model\n    print(f\"{name} trained successfully.\")",
    "#evaluate the models\nfor name, model in trained.items():\n    y_pred = model.predict(X_test)\n    y_proba = model.predict_proba(X_test)[:, 1]\n\n    print(f\"\\n{name}\")\n    print(\"Accuracy:\", accuracy_score(y_test, y_pred))\n    print(\"Precision:\", precision_score(y_test, y_pred))\n    print(\"Recall:\", recall_score(y_test, y_pred))\n    print(\"F1 Score:\", f1_score(y_test, y_pred))\n    print(\"AUC:\", roc_auc_score(y_test, y_proba))",
    "#lets identify the high risk borrowers by Picking the best model (let's assume RandomForest)\nbest = trained[\"Random Forest\"]\n\ndf['risk_probability'] = best.predict_proba(X)[:, 1]\ndf['high_risk'] = (df['risk_probability'] < 0.4).astype(int)\n\ndf[['risk_probability', 'high_risk']].head()",
    "import joblib\n\njoblib.dump(model, \"loan_model.pkl\")\nprint(\"Model saved!\")",
    "pip install fastapi uvicorn joblib",
    "from fastapi import FastAPI\nimport joblib\nimport numpy as np\n\napp = FastAPI()\n\n# load saved model\nmodel = joblib.load(\"loan_model.pkl\")\n\n@app.get(\"/\")\ndef home():\n    return {\"message\": \"Loan Recovery Prediction API is running!\"}\n\nEXPECTED_FEATURES = [\"Payment_History\", \"Monthly_Income\", \"Loan_Amount\"]\nmodel = joblib.load(\"loan_model.pkl\")\n\n@app.post(\"/predict\")\ndef predict_loan(\n    data: dict = {\n        \"Payment_History\": \"on-time\",\n        \"Monthly_Income\": 50000,\n        \"Loan_Amount\": 20000\n    }\n):\n    # Your existing prediction logic here\n    pass\n\n    # predict probability\n    prob = model.predict_proba(features)[0][1]   # probability of repayment\n\n    # classify borrower\n    high_risk = prob < 0.5\n\n    return {\n        \"repayment_probability\": float(prob),\n        \"high_risk_borrower\": bool(high_risk)\n    }",
    "@app.post(\"/predict\")\ndef predict_loan(data: dict):\n    try:\n        # Convert payment_history to numeric\n        if \"Payment_History\" in data:\n            data[\"Payment_History\"] = 0 if data[\"Payment_History\"] == \"delayed\" else 1\n        \n        # Convert to array\n        features = np.array([list(data.values())]).reshape(1, -1)\n        \n        # Predict probability\n        prob = model.predict_proba(features)[0][1]\n        high_risk = prob < 0.5\n\n        return {\n            \"repayment_probability\": float(prob),\n            \"high_risk_borrower\": bool(high_risk)\n        }\n    except Exception as e:\n        return {\"error\": str(e)}",
    "model = joblib.load(r\"C:\\Users\\USER\\Machine Learning\\Mlproject2\\loan_model.pkl\")",
    "print(model.n_features_in_)",
    ""
  ]
}